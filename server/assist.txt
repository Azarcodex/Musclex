// -----------------------------------------
//   COMPLETE RETURN (REFUND) â€” FIXED LOGIC
// -----------------------------------------
if (newStatus === "Completed") {
  const itemTotal = item.price * item.quantity;
  const couponDiscount = (item.discountPerItem || 0) * item.quantity;

  // FINAL accurate refund
  const refundAmount = itemTotal - couponDiscount; // <-- CORRECT

  if (refundAmount < 0) refundAmount = 0;

  // Vendor wallet check
  const vendorWallet = await VendorWallet.findOne({ vendorId });
  if (!vendorWallet || vendorWallet.balance < refundAmount) {
    return res.status(400).json({
      message: "Vendor does not have enough balance for refund",
    });
  }

  // Reverse vendor credit
  await reversalForOrder({
    vendorId: item.vendorID,
    orderId: order._id,
    amount: itemTotal,
    commissionPercent: 10,
  });

  item.vendorCreditStatus = "Reversed";

  // Refund to user wallet
  let userWallet = await Wallet.findOne({ userId: order.userID });
  if (!userWallet) {
    userWallet = await Wallet.create({
      userId: order.userID,
      balance: 0,
    });
  }

  userWallet.balance += refundAmount;
  await userWallet.save();

  await WalletLedger.create({
    walletId: userWallet._id,
    userId: order.userID,
    amount: refundAmount,
    type: "REFUND",
    referenceId: order.orderId,
    note: `Refund for item ${itemId}`,
  });

  // Restore stock
  const variant = await Variant.findById(item.variantID);
  if (variant) {
    const sizeObj = variant.size.find((s) => s.label === item.sizeLabel);
    if (sizeObj) sizeObj.stock += item.quantity;
    await variant.save();
  }

  // Final updates
  item.returnStatus = "Completed";
  item.refundStatus = "Completed";
  item.refundAmount = refundAmount;
  item.status = "Returned";

  await order.save();

  return res.json({
    success: true,
    message: "Return completed & refunded successfully",
    refundAmount,
    order,
  });
}
