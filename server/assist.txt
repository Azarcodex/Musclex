export const cancelProductOrder = async (req, res) => {
  try {
    const userId = req.user._id;
    const { orderId, item_id } = req.params;
    const { reason } = req.body;

    const order = await Order.findOne({ _id: orderId, userID: userId });
    if (!order) return res.status(404).json({ message: "Order not found" });

    const item = order.orderedItems.find(
      (it) => it._id.toString() === item_id.toString()
    );
    if (!item) return res.status(404).json({ message: "Item not found" });

    const cancellable = ["Pending", "Confirmed", "Processing"];
    if (!cancellable.includes(item.status)) {
      return res.status(400).json({
        message: `Item cannot be cancelled once it is ${item.status}`,
      });
    }

    // ------------------------------------------------------------
    // 1) RESTORE STOCK
    // ------------------------------------------------------------
    if (!item.StockRestored) {
      const variant = await Variant.findById(item.variantID);
      const sizeObj = variant.size.find((s) => s.label === item.sizeLabel);
      if (sizeObj) sizeObj.stock += item.quantity;
      await variant.save();
      item.StockRestored = true;
    }

    // ------------------------------------------------------------
    // 2) MARK ITEM CANCELLED
    // ------------------------------------------------------------
    item.status = "Cancelled";
    item.cancelReason = reason;

    // ------------------------------------------------------------
    // 3) CHECK IF COUPON BECOMES INVALID
    // ------------------------------------------------------------
    let couponInvalidated = false;

    if (order.couponApplied) {
      let remainingSubtotal = 0;

      for (const it of order.orderedItems) {
        if (it.status !== "Cancelled") {
          remainingSubtotal += it.price * it.quantity;
        }
      }

      if (remainingSubtotal < order.minPurchaseforCoupon) {
        couponInvalidated = true;
        order.couponApplied = false;
        order.couponCode = null;
      }
    }

    // ------------------------------------------------------------
    // 4) CALCULATE REFUND (USING discountPerItem ONLY)
    // ------------------------------------------------------------
    let refundAmt = 0;

    if (
      (order.paymentMethod === "Razorpay" ||
        order.paymentMethod === "Wallet") &&
      order.paymentStatus === "Paid"
    ) {
      const itemTotal = item.price * item.quantity;

      if (couponInvalidated && order.discount > 0) {
        // Coupon broken → recover full coupon from THIS item
        refundAmt = itemTotal - order.discount;
        order.discount = 0;
      } else {
        // Normal case → per item refund
        refundAmt = itemTotal - (item.discountPerItem || 0);
      }

      refundAmt = Math.max(refundAmt, 0);
      refundAmt = Math.min(refundAmt, order.paidAmount);

      const wallet = await Wallet.findOne({ userId });
      wallet.balance += refundAmt;
      await wallet.save();

      await WalletLedger.create({
        walletId: wallet._id,
        userId,
        amount: refundAmt,
        type: "ADD",
        referenceId:
          order.paymentMethod === "Razorpay"
            ? order.paymentId || "RAZORPAY_REFUND"
            : "WALLET_REFUND",
        note: "Refund for item cancellation",
      });

      item.refundAmount = refundAmt;
      item.refundStatus = "Completed";
    } else {
      item.refundAmount = 0;
      item.refundStatus = "Not Applicable";
    }

    // ------------------------------------------------------------
    // 5) UPDATE PAID AMOUNT (NO finalAmount RECOMPUTE)
    // ------------------------------------------------------------
    order.paidAmount -= refundAmt;
    if (order.paidAmount < 0) order.paidAmount = 0;

    // ------------------------------------------------------------
    // 6) FINAL ORDER STATUS
    // ------------------------------------------------------------
    const allCancelled = order.orderedItems.every(
      (it) => it.status === "Cancelled"
    );
    if (allCancelled) order.orderStatus = "Cancelled";

    await order.save();

    return res.json({
      success: true,
      message:
        refundAmt > 0
          ? "Item cancelled & refunded to wallet"
          : "Item cancelled successfully",
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ message: "Internal Server Error" });
  }
};
